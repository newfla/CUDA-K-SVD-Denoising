@startuml BuildImageDenoisedDiagram
|HOST|
|#AntiqueWhite|DEVICE|
start
floating note: Pink == parallel exec
partition DxS {
    #HotPink:noisePatches = SGEMM(dictionary, sparseCode);
    |HOST|
    :noisePatches.copyOnHost();
}

partition RebuildAfirstImage {
    :img = new host_vector(imageDim, 0);
    while (currPixel < image_Dim)
        :currPatch = 0;
        while(currPatch < nPatches)
            if(currPixel in currPatch?) then (yes)
                :img[currPixel] = currPatchFindMatch[currPixel].value();
                :weightsPixel[currPixel]++;
            endif
            :currPatch++;
        endwhile
        :currPixel++;
    endwhile
     
    #HotPink:tempImg = weight(img,pixelsWeight);
}

partition FindLamba {
    #HotPink:tempImg = weightedImage(img,pixelsWeight);
    #HotPink:distance = Pixels distance Point by Point (originalImg, tempImg);
    :lambda = abs(sqrt(l2Norm(temp) / (noiseVariance * imgDims)) -1);
}

partition BuildImage {
    #HotPink: tempImg = transform(originalImg, d, "coffMult");
    #HotPink: img = transform(tempImg, img, "Sum Point by Point");
    #HotPink: tempImg = transform(weightList, d, "coffAdd");
    #HotPink: img = transform(img, tempImg, "Divide Point by Point");
}

partition SaveImage {
    :file = new Cimg(img, originalImg.height, originalImg.width);
    :file.transpose();
    :file.save(filePath);
}

stop


@enduml